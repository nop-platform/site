# 在线动态建模

无代码（NoCode）开发模式要求用户可以在线调整数据模型、流程模型等模型对象，无需经过编译、打包、部署的的过程，立刻就能够看到模型调整后的运行结果。

Nop平台目前的演示大部分是在开发阶段进行模型设计，然后通过代码生成来产生程序源码，很多人因此误以为Nop平台的技术方案并不适用于在线动态建模。

在本文中，我将结合Nop平台中的NopDyn模块的实现，介绍一下Nop平台中动态模型管理方面的内容。

# 一. 通过DSL实现解耦

为了支持运行时进行模型设计的动态性，传统的技术实现方案中设计工具和运行时引擎结合得非常紧密，这导致两者之间的逻辑相互纠缠，无论是设计改进还是性能改进都会遇到很多限制。

$$
设计态 \Longrightarrow 运行态
$$

Nop平台强调DSL优先，而不是可视化设计优先。（参见[从可逆计算看DSL的设计要点](https://zhuanlan.zhihu.com/p/646144092)）

$$
设计态 \overset {代码生成} \Longrightarrow  虚拟文件系统 \overset {通用加载} \Longrightarrow 运行态
$$

在Nop平台中，设计工具和运行时引擎通过DSL实现了解耦。

1. 设计工具的输出产物是DSL模型文件

2. 运行时引擎的输入信息是DSL模型文件

3. **DSL模型文件由虚拟文件系统统一管理**

借助于虚拟文件系统的抽象，DSL的实际存储形式可以是硬盘上的文件，也可以是数据库中的某条记录（或者是一组关联的记录），也可以是内存中的一段文本缓存。模型保存为DSL文件然后再解析得到运行时模型对象的过程可以看作是**对JSON序列化过程的一种非对称扩展**：设计时模型序列化后产生的文本是DSL，而**反序列化得到的运行时模型并不需要与设计时模型一致**，而完全可以是一种针对运行时优化后的模型结构。

$$
Model \Longrightarrow  JSON  \Longrightarrow Model \\
DesignModel \Longrightarrow DSL \Longrightarrow RuntimeModel
$$

更进一步，**从设计时模型到DSL的产生过程并不是唯一的**，我们完全可以针对不同的业务使用场景提出多种不同形式的设计时模型，只需要它们可以通过某种代码生成过程产生我们所需的DSL文本结构即可。例如，在Nop平台中底层的工作流引擎并不是针对审批场景定制的工作流引擎，它没有内置的会签、串签等概念，但是我们可以提供一个定制的、类似钉钉工作流的可视化设计器，它产生一种树形结构的模型对象，然后再通过编译期模型转换自动生成底层的图结构的工作流DSL。

也就是说，从DesignModel到DSL可以是一个代码生成的过程，它可以通过一个代码生成器来完成。一说到代码生成，很多人的第一印象就是它是开发阶段才存在的概念，不适合于动态模型设计。但是如果结合虚拟文件系统的抽象，代码生成与JSON序列化并没有本质上的差异：都是生成内存中的一段文本而已。

Nop平台内置了强大的模板驱动的代码生成器，可以实现NoCode开发与ProCode开发共享一部分代码生成模板。参见[数据驱动的差量化代码生成器](https://zhuanlan.zhihu.com/p/540022264)。

在另一个方向上，**解析DSL得到模型对象的过程在Nop平台中被标准化了**：只需要定义DSL所对应的XDef元模型，即可自动实现模型对象解析。参见[替代XSD的统一元模型定义语言:XDef](https://zhuanlan.zhihu.com/p/652191061)。

在Nop平台中，我们可以使用如下方式来根据虚拟文件路径加载任意模型对象

```javascript
DslModel = ResourceComponentManager.instance().loadComponentModel(modelPath)
```

加载过程中会自动实现模型缓存，并跟踪模型文件之间的依赖关系：当某个模型文件被修改之后，所有依赖于该模型文件的模型缓存会自动失效。统一模型加载器所做的工作本质上类似于前端的webpack、vite这种支持依赖跟踪的打包工具。详细介绍视频参见[低代码平台中的统一模型加载器](https://www.bilibili.com/video/BV1rH4y117hd/)。

# 二. 通用的Delta差量化机制

**任何一种动态更新(扩展)技术本质上都是在定义一种Delta差量空间以及这个空间中可行的结构合成运算**。仔细思考一下就知道，一般人眼中所谓的动态更新无非就是在已经构造好的结构上定义扩展点，然后将符合接口规范的结构插入到扩展点中。实现动态的差量化更新的复杂性体现在如下三点：

1. 如何设计扩展点才能保证满足未知的差量更新需求？

2. 如何实现外部引入的差量结构与原有的结构无缝融合？

3. 如何保证差量化更新前后运行时状态的一致性？

除了以上三点，我们还可以问自己一个问题：既然所有的业务逻辑结构都存在潜在的动态更新需求，**为什么每一个特定的结构都要单独定制自己的差量更新方案**？能否通过一种统一的技术方案一举解决上面三个技术难题？

## 关系模型的成功经验
为了回答上面的问题，我们可以参考关系模型的发家历史。在关系数据库一统江湖之前，数据存储的方式可谓是五花八门，八仙过海各显神通。但是关系数据库模型之所以能够标准化存储机制，是它选择后退一步海阔天空。在关系模型中我们放弃了数据之间天然存在的各种关联关系，**将关注的重点完全集中在原子化的无冗余的数据上**，把它们按照规范处理好之后，再通过各种衍生运算动态计算得到最终需要的数据。特别的，所有数据间原有的指针强关联都被打破，所有的关系都被分解（所谓的**关系数据库中无关系**），仅保留id和ref_id这种关联字段信息，在运行时（实际需要使用数据的时候），我们再使用join语句，**通过即时的计算**（索引查找或者表扫描），在内存中**重建数据之间的关系**。再次强调一下，关系模型的强大依赖于它将即时计算引入标准化结构数据的存取过程，在运行时重建关系，而ORM引擎的作用是将关系模型中被分解掉的关系重新捡回来，内置在对象模型中，避免在业务表达时总是频繁重复表达主外键关联关系。

为了实现无歧义、标准化的差量更新，可逆计算理论的选择与关系模型一样，同样是后退一步，在标准化的无冗余的结构层进行操作，而不是在按照类型出现分化的对象层上进行操作。Nop平台中的差量合并机制统一定义在XDSL层面，它是一种标准化的、可以采用XML或者JSON格式表达的信息结构，通过元模型XDefinition进行结构约束。

| 关系模型理论             | 可逆计算理论            |
| ------------------ | ----------------- |
| Schema定义           | XDefinition元模型规范  |
| 无冗余的表格数据           | 无信息冗余的树形信息结构：XDSL |
| 在标准化数据结构基础上的即时计算：SQL |在通用的XNode数据结构基础上的编译期计算：XLang |

Nop平台的XLang相当于是发展了一整套系统化的对Tree结构的定义、解析、转换、分析的工具集。Nop平台之所以能够实现标准化的、与业务无关的差量合并运算，原因在于它是在通用的XDSL结构层定义差量运算，而不是在XDSL解析得到的模型对象层。

回顾一下Nop平台中的模型加载过程

```javascript
DslModel = ResourceComponentManager.instance().loadComponentModel(modelPath)
```
如果采用函数式语言的抽象表达形式，它对应于

```
   modelPath => XDSL => DslModel 
```

XDSL是无冗余的、标准化的、面向信息存储和传递的结构化信息表达形式，而DslModel是经过编译优化、提供大量衍生数据的、面向对外使用的信息表达形式。它们两者之间通过一个动态的响应式计算过程联系起来：一旦DSL文件被修改，DslModel就自动重新解析。

## 微服务架构的成功经验

差量化更新时如何保证运行时状态在更新前后的一致性？对于这个问题的回答，我们可以参考一下微服务架构的解决方案。

微服务架构之所以能够实现动态滚动更新，依赖于所谓的无状态设计。面向对象的传统做法是函数和它所处理的函数封装到所谓的对象中，最后函数和数据相互纠缠，形成意大利面条般盘根错解的混乱结构，难以进行拆解，自然也难以做到局部更新。理想的情况下，最好形成类似千层饼的切片结构，随时可以一层层的叠加或者削减。
无状态设计的本质是实现逻辑处理和运行时状态空间的解耦。清气上升，浊气下沉，运行时的动态状态数据从静态的纯逻辑处理结构中被排挤出去，一部分成为被传递的参数数据，另一部分成为保存在共享存储中的持久化数据，这样微服务本身的运行时结构中就不再明确包含状态数据，因此它的动态更新也就不和状态空间的数据迁移纠缠在一起，成为一个可以被独立解决的问题。

访问微服务的时候我们会先访问服务注册中心，通过服务名动态查找得到服务实例，然后再向它发送输入参数，服务实例根据输入参数再自动加载持久化状态数据。如果采用函数式语言的抽象表达形式，微服务的处理过程对应于

```
  serviceName => Service => input => state => Result
```

类似的，在Nop平台中，所有模型的处理过程都采用同样的逻辑结构

```
  modelPath => XDSL => DslModel => arguments => scope => Result
```

类似于微服务，DSL模型的动态更新可以独立于状态空间的结构迁移。

# 三. DSL
